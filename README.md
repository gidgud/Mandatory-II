# Mandatory-II
Tech Mandatory II assignment 
1. Can navigate the terminal: ls, cd, whoami, pwd.
   
<img width="317" height="164" alt="image" src="https://github.com/user-attachments/assets/e2168d1a-757b-44d7-88dd-eed1966f4ebf" />

2. Can create, delete files / folders: mkdir, rm, cp, mv, touch, nano.
   
<img width="473" height="496" alt="image" src="https://github.com/user-attachments/assets/0680977a-dff6-48c4-866e-6519962e76c0" />

3. Can use the following basic terminal commands: cat, wc, uniq, sort.

<img width="371" height="476" alt="image" src="https://github.com/user-attachments/assets/039ea5de-f001-4ac1-b6b7-1a4f61e89e2a" />

4. Can create a new repository in your prefered Git provider.

<img width="756" height="767" alt="image" src="https://github.com/user-attachments/assets/1bd9f576-51af-4413-b150-4967acf8474e" />

5. Can perform basic Git operations: clone, add, commit, push, pull.

<img width="729" height="376" alt="image" src="https://github.com/user-attachments/assets/abcf4aca-5fb0-4ccd-832a-b2a754f5b199" />

6. Understands the basic hardware components of a computer system and the Von Neumann architecture.

Basic hardware components:
A computer has a CPU (brain), RAM (temporary memory), storage (permanent memory like SSD) and input/output devices (keyboard, monitor).

Von Neumann architecture:
Programs and data are stored together in the same memory.
The CPU fetches instructions from memory one by one, executes them and stores results back.
This design allows any program to run on the same hardware.

7. Knows about different types of databases and their use cases.

Relational Databases (SQL):
Structured tables, rows/columns, ACID transactions, SQL queries, relationships.
Banking, inventory systems, CRM - anywhere you need strict data consistency and complex relationships.

NoSQL Document Databases:
JSON-like documents, flexible schema, nested data.
Content management, user profiles, catalogs - when data structure varies or evolves frequently.

Key-Value Stores:
Simple lookups, blazing fast, cache, session storage.
Shopping carts, user sessions, real-time recommendations - need speed over complex queries.

Column-Family Databases:
Wide columns, time-series, massive scale, write-heavy.
IoT sensor data, analytics, event logging - huge volumes of writes with predictable access patterns.

Graph Databases:
Nodes, edges, relationships, traversal, connections.
Social networks, recommendation engines, fraud detection - when relationships between data are as important as the data itself.

Time-Series Databases:
Timestamps, metrics, optimized for time-based queries, retention policies.
Monitoring systems, financial trading, IoT analytics - data points indexed by time.

In-Memory Databases:
RAM-based, microsecond latency, volatile/persistent options.
Real-time bidding, leaderboards, rate limiting - when milliseconds matter.



8. Can setup a new MySQL database and connect to it.

<img width="441" height="50" alt="image" src="https://github.com/user-attachments/assets/cb5b0700-9948-4084-931a-1eacc5fc0a5c" />

<img width="789" height="642" alt="image" src="https://github.com/user-attachments/assets/6fe829cb-c663-421b-a2e3-5bb2f9130ed5" />

9. Can create DDL statements to create tables.

<img width="262" height="145" alt="image" src="https://github.com/user-attachments/assets/69d4f0fd-5259-4c22-a773-d24db00b2f98" />

10. Can create DML (SELECT, INSERT) statements.

<img width="361" height="65" alt="image" src="https://github.com/user-attachments/assets/0bd1a963-59e1-4729-b7e6-60ce790a4039" />

11. Can use WHERE clause to filter results.

<img width="306" height="33" alt="image" src="https://github.com/user-attachments/assets/e4e08ed1-1668-4f45-960d-f98cac0e5b55" />


12. Can define Primary Keys.

<img width="262" height="145" alt="image" src="https://github.com/user-attachments/assets/69d4f0fd-5259-4c22-a773-d24db00b2f98" />

13. Understands how Foreign Keys work.

Foreign keys are used to reference a table with a primary key, to connect the 2 tables u use join.

14. In SELECT statements, can use (with moderate help):


        LIMIT, ORDER BY, GROUP BY

        aggregate functions like COUNT, SUM, AVG, MIN, and MAX

        pattern matching with LIKE and wildcards

        JOIN to combine data from multiple tables

<img width="583" height="818" alt="image" src="https://github.com/user-attachments/assets/0bd5b947-64b2-47f0-9f1f-5f976d36d8b1" />

16. Can create inner, left and right joins after looking up the syntax.

<img width="646" height="612" alt="image" src="https://github.com/user-attachments/assets/7036348c-044c-4d69-9995-cf437a4ec3b4" />

17. Can create DDL statements to create tables with constraints: PRIMARY KEY, AUTO_INCREMENT, FOREIGN KEY, UNIQUE, NOT NULL.

<img width="460" height="107" alt="image" src="https://github.com/user-attachments/assets/190e43f0-3505-4a31-9b36-d420318ef665" />

18. Can create DML (UPDATE, DELETE) statements.

<img width="415" height="521" alt="image" src="https://github.com/user-attachments/assets/cbea6cc3-decf-458c-9566-bbedc7ce8c7d" />

19. Can create a pull request.

<img width="701" height="441" alt="image" src="https://github.com/user-attachments/assets/2e12e26c-567a-4930-a81b-d2bd09358903" />

<img width="894" height="714" alt="image" src="https://github.com/user-attachments/assets/595787e8-645e-4813-9918-b2eb14a2038c" />

20. Understands different Git workflows such as GitHub Flow.

Git Workflows & GitHub Actions Reference
GitHub Flow is a lightweight, branch-based workflow designed for teams and projects with regular deployments.
Core principles:

Main branch is always deployable - production-ready code only

Feature branches - create descriptive branches from main for new work

Pull Requests - open PR early for discussion and code review

Deploy from branch - test in production-like environment before merging

Merge to main - after approval and passing tests

Delete branch - clean up after merging

Typical workflow steps:

Create branch from main: feature/add-login

Make commits with clear messages

Open Pull Request for review

Discuss and review code changes

Deploy and test (optional)

Merge to main after approval

Delete feature branch

21. Can solve a merge conflict.

<img width="682" height="1045" alt="image" src="https://github.com/user-attachments/assets/ee50b67e-815d-48b1-87f5-eef638251349" />

<img width="674" height="79" alt="image" src="https://github.com/user-attachments/assets/3fd34e61-ed5f-4476-ae42-62690d4bdde6" />

22. Can write YAML files.

<img width="328" height="1027" alt="image" src="https://github.com/user-attachments/assets/075f1afc-68ab-4d41-b1c8-f0991f917dfb" />

23. Understands what GitHub Actions are and can breakdown workflows into runners, jobs, and steps.

GitHub Actions is CI/CD automation built into GitHub. Workflows run in response to events (push, PR, schedule, etc.).
Architecture Breakdown:
Workflow → Jobs → Steps

Workflow: YAML file in .github/workflows/ defining automation
Runner: Server that executes jobs (GitHub-hosted or self-hosted)
Job: Set of steps that run on the same runner
Step: Individual task (run command or action)

Component Details:
Runners:

Virtual machines that execute workflows
GitHub-hosted: ubuntu-latest, windows-latest, macos-latest
Self-hosted: Your own servers for custom requirements
Each job runs on a fresh runner instance

Jobs:

Run in parallel by default (can be sequential with needs)
Each job runs on a separate runner
Can have dependencies between jobs
Can share data via artifacts or outputs

Steps:

Sequential tasks within a job
Can run shell commands or reusable actions
Share the same runner environment
Access to $GITHUB_ENV and other context variables

24. Can give use cases for GitHub Actions.

Continuous Integration (CI)
Purpose: Catch bugs early, ensure code quality, validate PRs before merge.

Continuous Deployment (CD)
Purpose: Automate deployments, reduce manual errors, faster releases.

Scheduled Tasks
Purpose: Automated maintenance, report generation, cleanup tasks.

Code Quality Checks
Purpose: Detect vulnerabilities, enforce code standards, maintain security.

Multi-Environment Testing
Purpose: Ensure compatibility across platforms and versions.

Documentation Generation
Purpose: Keep documentation in sync with code changes.

Issue/PR Automation
Purpose: Automate project management, triage issues, enforce policies.

Release Management
Purpose: Automate versioning, generate changelogs, publish packages.
